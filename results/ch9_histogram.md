# Parallel histogram

병렬 히스토그램(Parallel Histogram) 계산의 최적화는 **여러 스레드가 동시에 동일한 메모리 위치를 수정할 때 발생하는 출력 간섭(output interference) 문제를 해결** 하고, 그 해결책으로 인해 발생하는 **성능 저하를 최소화** 하는 과정을 목표로 합니다.  
최적화는 **원자적 연산의 도입 → 경쟁(contention) 감소 → 메모리 접근 패턴 개선**의 순서로 점진적으로 이루어집니다.

---
## **Experiment Results**
| Kernel                | Excution time (ms) |
|----------------------------|----------------|
| **Basic Atomic**          | 53.931839 ms    |
| **Privatized Global Memory**  | 0.040032 ms     |
| **Privatized Shared Memory** | 0.019744 ms  |
| **Coarsened Contiguous**   | 0.018432 ms  |
| **Coarsened Interleaved**   | 0.016640 ms  |
| **Aggregation**   | 0.023552 ms  |

---

## **1단계: Atomic Operation**

### **문제점: Race Condition**  
- 병렬 히스토그램에서는 여러 스레드가 동시에 동일한 히스토그램 통(bin)의 카운터를 증가시키려고 할 수 있습니다.  
- 이 과정에서 **읽기-수정-쓰기(read-modify-write)** 단계가 겹치면 경쟁 상태가 발생합니다.  
- 예시:  
  두 스레드가 동시에 값 `0`을 읽고 `+1` 연산 후 `1`을 쓰면, 최종 결과는 `2`가 아닌 `1`이 되어 **업데이트 손실** 이 발생합니다.

### **기본 해결책: Atomic Operation**  
- `atomicAdd()`와 같은 **Atomic Operation**을 사용해 읽기-수정-쓰기를 단일 연산으로 묶습니다.  
- 이렇게 하면 동일한 메모리 위치에 대한 동시 업데이트가 **serialize** 되어 데이터 무결성이 보장됩니다.

### **성능 한계**  
- 원자적 연산은 메모리 **throughput** 이 아닌 **latency** 에 좌우됩니다.  
- 경쟁이 심한 통에서는 **직렬화로 인한 병목** 이 심각하게 발생합니다.  
- 최신 GPU는 L2 캐시에서 원자적 연산을 처리해 지연 시간을 줄였지만 **근본적인 직렬화 문제는 여전** 합니다.

---

## **2단계: Privatization**

### **최적화 원리**  
- **원자적 연산의 경쟁을 줄이기 위해 히스토그램을 여러 사적인 복사본(private copies)으로 분할** 합니다.  
- 가장 일반적인 방법은 **스레드 블록마다 하나의 사적 히스토그램** 을 할당하는 것입니다.

### **핵심 포인트**  
- **경쟁 감소**: 스레드들은 자신이 속한 블록 내에서만 경쟁하므로 충돌이 크게 줄어듭니다.  
- **공유 메모리 활용**: 블록별 사적 복사본은 지연 시간이 매우 짧은 **shared memory** 에 저장할 수 있어 원자적 연산 처리량이 크게 증가합니다.

### **단점**  
- 계산이 끝난 후 **모든 사적 복사본을 최종 public copy으로 병합(merge)** 해야 하며, 이 과정에서 **추가 오버헤드**가 발생합니다.
- 이 병합 작업은 스레드 블록마다 한 번씩 수행되므로, **사용한 스레드 블록의 수가 많을수록 병합 오버헤드도 커집니다.**

---

## **3단계: Thread Coarsening**

### **최적화 원리**  
- 사유화의 **병합 오버헤드**를 줄이기 위해, **스레드 블록 수를 줄이고 각 스레드가 더 많은 입력 데이터를 처리**하도록 조정합니다.

### **데이터 분할 전략**  
1. **Contiguous Partitioning**  
   - 각 스레드가 연속된 데이터 청크(chunk)를 처리합니다.  
   - 하지만 **memory coalescing에 불리**할 수 있습니다.

2. **Interleaved Partitioning**  
   - 스레드들이 **전체 스레드 개수만큼의 보폭(stride)**으로 데이터를 번갈아 가져옵니다.  
   - 이 방식은 워프(warp) 내 스레드들이 **연속된 메모리 위치에 접근**하게 되어 **메모리 병합을 극대화**할 수 있습니다.

---

## **4단계: Aggregation**

### **최적화 원리**  
- 데이터셋에 **특정 값이 집중적으로 등장**하는 경우(예: 사진 속 푸른 하늘)에 효과적입니다.  
- **동일한 히스토그램 통에 대한 연속 업데이트를 하나의 원자적 연산으로 합칩니다.**

### **핵심 포인트**  
- 각 스레드는 레지스터에 **accumulator**를 두고 동일 통에 대한 업데이트를 모읍니다.  
- 다른 값이 나타나면 누적 값을 **한 번의 원자적 연산**으로 반영합니다.

### **효과**  
- 경쟁이 심한 통에 대한 **원자적 연산 횟수를 줄여 처리량 향상**.  
- 하지만 데이터 분포가 균일할 경우, **추가 로직 때문에 성능이 오히려 저하될 수 있음**.

---
## **최종 결론**
(1) Atomic Operation: 여러 스레드가 동시에 동일한 메모리 위치를 업데이트할 때 발생하는 **race condition**를 해결합니다. 하지만 이는 연산을 직렬화하여 심각한 성능 병목을 유발합니다.  
(2) Privatization: 스레드 블록별로 **private copies**을 만들어 경쟁을 줄이고, 이를 공유 메모리에 저장하여 atomic operation의 지연 시간을 최소화합니다.  
(3) Thread Coarsening: 각 스레드가 더 많은 데이터를 처리하게 하여 **스레드 블록의 수를 줄이고**, 이를 통해 사유화의 병합 오버헤드를 감소시킵니다. 이때 메모리 접근 효율을 높이기 위해 **interleaved partitioning** 방식을 사용합니다.  
(4) Aggregation: 데이터가 특정 값에 집중될 경우, 스레드 내에서 로컬 변수를 사용해 **업데이트를 모았다가 한 번에 atomic operation을 수행**하여 총 연산 횟수를 줄입니다.  


