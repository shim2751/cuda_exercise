스텐실 커널의 점진적 최적화 원리 요약 (Markdown)
스텐실(Stencil) 계산의 커널 최적화는 

데이터 재사용성(Data Reuse)을 극대화하여 GPU의 느린 글로벌 메모리(Global Memory) 접근을 최소화하고, 빠른 온칩 메모리(On-chip Memory), 즉 공유 메모리와 레지스터를 효율적으로 활용하는 방향으로 점진적으로 진행됩니다.. 각 최적화 단계는 이전 단계의 한계를 극복하는 방식으로 이루어집니다.


1단계: 기본 커널 (Baseline Kernel)
원리 및 문제점
기본 커널은 가장 직관적인 방식으로, 하나의 스레드가 하나의 결과 그리드 포인트(grid point) 계산을 책임집니다. 계산에 필요한 모든 입력 데이터(예: 3D 7-point 스텐실의 경우 7개의 이웃 데이터)를 

매번 글로벌 메모리에서 직접 읽어옵니다.





핵심 문제: 이 방식은 **메모리 대역폭 한계(Memory-bound)**에 부딪힙니다.

3D 7-point 스텐실의 경우, 13개의 부동소수점 연산(곱셈 7, 덧셈 6)을 위해 7개의 4바이트 입력값을 글로벌 메모리에서 읽어야 합니다.

이때 연산/메모리 접근 비율(OP/B, Operations per Byte)은 약 

0.46 OP/B에 불과합니다.

이는 GPU의 높은 연산 성능을 전혀 활용하지 못하고 대부분의 시간을 메모리 접근에 소모하게 만듭니다.

2단계: 공유 메모리 타일링 (Shared Memory Tiling)
최적화 원리
글로벌 메모리 접근을 줄이기 위해 **공유 메모리(Shared Memory)**를 활용합니다. 스레드 블록(Thread Block) 내의 모든 스레드들이 협력하여 자신들이 계산할 결과물 영역(Output Tile)에 필요한 모든 입력 데이터(Input Tile)를 

한 번에 공유 메모리로 가져옵니다. 이후 스레드들은 매우 빠른 공유 메모리에서 데이터를 읽어 계산을 수행합니다.



핵심 원리: 데이터 재사용. 공유 메모리에 로드된 하나의 입력 데이터는 결과 타일을 계산하는 여러 스레드에 의해 재사용될 수 있습니다.

새로운 문제점 (3D 환경의 한계)
2D 이미지 처리에 주로 쓰이는 컨볼루션(Convolution)과 달리, 3D 그리드에서 스텐실을 적용하면 새로운 문제가 발생합니다.


높은 헤일로 오버헤드 (Halo Overhead): 3D 타일은 부피에 비해 표면적(헤일로 셀)의 비율이 매우 높습니다.

예를 들어, 8x8x8 입력 타일(512개 원소)은 6x6x6 출력 타일(216개 원소)을 생성하는데, 이때 헤일로 셀은 296개로 전체 입력의 **58%**에 달합니다. 이는 데이터 재사용의 효율을 크게 떨어뜨립니다.



하드웨어 제약: GPU의 스레드 블록 당 스레드 수 제한(예: 1024개) 때문에 3D 타일의 한 변의 길이(T)를 키우기 어렵습니다.

실질적인 T의 한계는 8이며, 이는 8x8x8=512 스레드 블록을 구성합니다.

이렇게 작은 타일 크기는 연산/메모리 접근 비율을 이론적 최대치(3.25 OP/B)보다 훨씬 낮은 

1.37 OP/B로 제한합니다.

3단계: 스레드 거칠기 (Thread Coarsening)
최적화 원리
타일링의 한계를 극복하기 위해 

한 스레드가 처리하는 작업의 양을 늘립니다. 기존에 스레드 하나가 포인트 하나를 계산했다면, 이제는 

z축 방향으로 여러 개의 포인트(하나의 컬럼)를 순차적으로 계산하도록 만듭니다.

핵심 원리:


더 큰 2D 타일 사용 가능: 스레드 블록을 2D(예: T²)로 구성하고 z축 방향으로 순회하며 계산하므로, 스레드 수 제한을 피하면서 x, y 차원의 타일 크기를 32x32 등으로 크게 늘릴 수 있습니다.


데이터 재사용률 향상: 타일 크기가 커지면서 헤일로 오버헤드가 줄어들어 연산/메모리 접근 비율이 크게 향상됩니다.


공유 메모리 절약: 계산에 필요한 모든 3D 입력 타일을 한 번에 올릴 필요 없이, 현재 z축 평면 계산에 필요한 활성 평면(active planes) 3개만 유지하면 됩니다. 이로써 공유 메모리 요구량이 

T³에서 3 * T²로 감소합니다.

4단계: 레지스터 타일링 (Register Tiling)
최적화 원리
스레드 거칠기 방식의 데이터 접근 패턴을 더 깊이 분석하여 최적화합니다. 7-point 스텐실의 경우, z축 방향의 이웃 데이터(

inPrev_s, inNext_s)는 오직 하나의 스레드에 의해서만 사용된다는 특성이 있습니다. 여러 스레드가 공유할 필요가 없는 데이터는 공유 메모리보다 더 빠른 **레지스터(Register)**에 저장합니다.



핵심 원리:


최고 속도 메모리 활용: 공유 메모리에 있던 inPrev_s와 inNext_s 데이터를 각 스레드의 개인 레지스터 변수(inPrev, inNext)로 옮깁니다. 레지스터는 공유 메모리보다 지연 시간(latency)이 훨씬 짧고 대역폭이 높아 코드 실행 속도를 높입니다.



공유 메모리 압박 완화: 공유 메모리 사용량이 1/3로 줄어듭니다. 오직 x-y 평면의 이웃 공유를 위해 필요한 

inCurr_s 데이터만 공유 메모리에 남습니다. 이는 더 많은 스레드 블록을 동시에 실행(높은 점유율, Occupancy)할 수 있는 여지를 만듭니다. 다만, 스레드당 레지스터 사용량은 늘어나는 트레이드오프가 있습니다.


결론적으로, 스텐실 커널 최적화는 

데이터의 재사용 패턴을 정확히 분석하여 가장 느린 글로벌 메모리부터 가장 빠른 레지스터까지 메모리 계층 구조를 체계적으로 활용하는 과정이라고 할 수 있습니다 . 각 단계는 이전의 병목 현상을 해결하고, GPU 아키텍처의 특성을 최대한 활용하여 연산 효율을 극한으로 끌어올립니다.


소스






