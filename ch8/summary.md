# 스텐실 커널의 점진적 최적화 원리

스텐실(Stencil) 계산의 커널 최적화는 **데이터 재사용성(Data Reuse)** 을 극대화하여 GPU의 느린 글로벌 메모리(Global Memory) 접근을 최소화하고, 빠른 온칩 메모리(On-chip Memory), 즉 **공유 메모리(Shared Memory)** 와 **레지스터(Register)** 를 효율적으로 활용하는 방향으로 점진적으로 진행됩니다.  
각 최적화 단계는 이전 단계의 한계를 극복하는 방식으로 이루어집니다.

---
## **실험 결과**
| Kernel                | Excution time (ms) |
|----------------------------|----------------|
| **Basic Stencil**          | 61.550114 ms    |
| **Shared Memory Stencil**  | 0.346720 ms     |
| **Thread Coarsening Stencil** | 0.276576 ms  |
| **Register Tiling Stencil**   | 0.249760 ms  |


---

## **1단계: 기본 커널 (Baseline Kernel)**

### 원리 및 문제점
- 하나의 스레드가 하나의 **그리드 포인트(Grid Point)** 계산을 담당.
- 계산에 필요한 모든 입력 데이터(예: 3D 7-point 스텐실의 경우 **7개의 이웃 데이터**)를 **매번 글로벌 메모리에서 직접 읽음**.

### 핵심 문제: 메모리 대역폭 병목 (Memory-bound)
- 3D 7-point 스텐실:
  - **13개의 부동소수점 연산** (곱셈 7, 덧셈 6)
  - **7개의 4바이트 입력값**을 글로벌 메모리에서 읽음.
- 연산/메모리 접근 비율 (**OP/B, Operations per Byte**) ≈ **0.46 OP/B**.
- GPU의 연산 성능을 활용하지 못하고 대부분의 시간을 메모리 접근에 소비.

---

## **2단계: 공유 메모리 타일링 (Shared Memory Tiling)**

### 최적화 원리
- 글로벌 메모리 접근을 최소화하기 위해 **스레드 블록(Thread Block)** 내 모든 스레드가 협력하여 **필요한 입력 타일(Input Tile)** 을 공유 메모리로 가져옴.
- 이후 계산은 **빠른 공유 메모리**에서 수행.

**핵심 원리:**  
- 데이터 재사용 극대화: 공유 메모리에 로드된 입력 데이터는 블록 내 여러 스레드가 **중복 사용**.

### 새로운 문제점 (3D 환경의 한계)
- **높은 헤일로 오버헤드 (Halo Overhead)**:
  - 예: 8×8×8 입력 타일(512개 원소) → 6×6×6 출력 타일(216개 원소).
  - 헤일로 셀: **296개 (전체의 58%)** → 데이터 재사용 효율 저하.
- **하드웨어 제약**:
  - 스레드 블록 당 스레드 수 제한(예: 1024개).
  - 3D 타일 크기(T) 한계: T = 8 (8³ = 512 스레드).
- **OP/B 제한**:
  - 이론적 최대치(3.25 OP/B) << 실제 1.37 OP/B.

---

## **3단계: 스레드 거칠기 (Thread Coarsening)**

### 최적화 원리
- 한 스레드가 **여러 포인트(컬럼)** 를 z축 방향으로 순차 계산.
- 스레드 블록을 **2D (T²)** 로 구성하고 z축을 순회.

**핵심 원리:**  
1. **더 큰 2D 타일 사용 가능**:
   - x, y 차원의 타일 크기를 32×32 등으로 확장 가능.  
2. **데이터 재사용률 향상**:
   - 타일 크기 확대 → 헤일로 오버헤드 감소 → OP/B 증가.  
3. **공유 메모리 절약**:
   - 3D 전체 타일(T³)을 한 번에 올리지 않고, z축 평면 3개(Active Planes)만 유지.
   - 메모리 요구량: **T³ → 3×T²**로 감소.

---

## **4단계: 레지스터 타일링 (Register Tiling)**

### 최적화 원리
- z축 방향 이웃 데이터 (**inPrev_s, inNext_s**)는 **한 스레드만 사용**.
- 공유 메모리 대신 **레지스터**에 저장하여 접근 속도 향상.

**핵심 원리:**  
1. **최고 속도 메모리 활용**:
   - inPrev_s, inNext_s → 각 스레드의 레지스터 변수 (inPrev, inNext).
   - 레지스터는 공유 메모리보다 지연 시간(latency)이 훨씬 짧음.
2. **공유 메모리 사용량 감소**:
   - 공유 메모리에서 z축 이웃 데이터를 제거.
   - **공유 메모리 사용량 1/3 감소** → 더 높은 **점유율(Occupancy)** 가능.
   - 단, 스레드당 레지스터 사용량이 늘어나는 트레이드오프 존재.

---

## **최종 결론**
스텐실 커널 최적화는 **데이터 재사용 패턴을 분석**하여 **글로벌 메모리 → 공유 메모리 → 레지스터** 순으로 **메모리 계층 구조를 최대한 활용**하는 과정입니다.  
각 단계는 **이전 병목 현상을 해소** 하며, GPU 아키텍처 특성을 활용해 **연산 효율을 극대화**합니다.
